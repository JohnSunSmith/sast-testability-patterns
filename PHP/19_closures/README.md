[//]: # (This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework.)

# Closures

Tags: sast, php, php_v7.4.9

Version: v1.0

## Description

[Closures or anonymous functions](https://www.php.net/manual/en/functions.anonymous.php) allow the creation of functions, that have no specific name. In PHP, a closure does not inherit the scope it was defined in. It rather encapsulates its scope and any variable that you want to access must be bind to the function manually.

Instance 2 targets the usage of [arrow functions](https://www.php.net/manual/en/functions.arrow.php). In PHP the implementation of arrow function uses the closure class as well, they both have the same features. Except arrow functions capture variables from the parent scope by value automatically.

## Overview

| Instances                 | has discovery rule   | discovery method   | rule successfull   |
|---------------------------|----------------------|--------------------|--------------------|
| [1 Instance](#1-instance) | yes                  | joern              | yes                |
| [2 Instance](#2-instance) | yes                  | joern              | error              |

<details markdown="1"open>
<summary>

## 1 Instance
</summary>

This instance captures the declaration of an unnamed function.

### Code

```PHP
<?php
$greet = function($name) {
    return $name;
};
$a = $_GET["p1"]; // source
$b = $greet($a);
echo $b; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| D2         | FEATURE                   | no                | yes                  | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=11, args=0, vars=3, tmps=7)
     ; (before optimizer)
     ; /.../PHP/19_closures/1_instance_19_closures/1_instance_19_closures.php:1-7
     ; return  [] RANGE[0..0]
0000 T3 = DECLARE_LAMBDA_FUNCTION 0
0001 ASSIGN CV0($greet) T3
0002 T5 = FETCH_R (global) string("_GET")
0003 T6 = FETCH_DIM_R T5 string("p1")
0004 ASSIGN CV1($a) T6
0005 INIT_DYNAMIC_CALL 1 CV0($greet)
0006 SEND_VAR_EX CV1($a) 1
0007 V8 = DO_FCALL
0008 ASSIGN CV2($b) V8
0009 ECHO CV2($b)
0010 RETURN int(1)

{closure}:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/19_closures/1_instance_19_closures/1_instance_19_closures.php:2-4
     ; return  [] RANGE[0..0]
0000 CV0($name) = RECV 1
0001 RETURN CV0($name)
0002 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

Declaring unnamed functions has an opcode statement `DECLARE_LAMBDA_FUNCTION`, which this rule searches for.

```scala
val x19 = (name, "19_closures_iall", cpg.call(".*DECLARE_LAMBDA_FUNCTION.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | Perfect             |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | yes      | yes      | no        | no          | no     | no    | yes            |
| 17 May 2023 | no       | no       |           |             |        |       | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

When it is easier for a SAST tool, to capture named functions, can one just rewrite an unnamed function and name it?

</details>

</details>

</details>

<details markdown="1">
<summary>

## 2 Instance
</summary>

This instance captures another possibility of declaring an unnamed function in php, using arrow functions.

### Code

```PHP
<?php
$b = $_GET["p1"]; // source
$fn1 = fn($x) => fn($y) => $x . $y;
$a =  $fn1("safe")($b);
echo a; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| D2         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=16, args=0, vars=4, tmps=9)
     ; (before optimizer)
     ; /.../PHP/19_closures/2_instance_19_closures/2_instance_19_closures.php:1-5
     ; return  [] RANGE[0..0]
0000 T4 = FETCH_R (global) string("_GET")
0001 T5 = FETCH_DIM_R T4 string("p1")
0002 ASSIGN CV0($b) T5
0003 T7 = DECLARE_LAMBDA_FUNCTION 0
0004 BIND_LEXICAL T7 CV2($y)
0005 ASSIGN CV1($fn1) T7
0006 INIT_DYNAMIC_CALL 1 CV1($fn1)
0007 SEND_VAL_EX string("safe") 1
0008 V9 = DO_FCALL
0009 INIT_DYNAMIC_CALL 1 V9
0010 SEND_VAR_EX CV0($b) 1
0011 V10 = DO_FCALL
0012 ASSIGN CV3($a) V10
0013 T12 = FETCH_CONSTANT string("a")
0014 ECHO T12
0015 RETURN int(1)
LIVE RANGES:
     7: 0004 - 0005 (tmp/var)

{closure}:
     ; (lines=6, args=1, vars=2, tmps=1)
     ; (before optimizer)
     ; /.../PHP/19_closures/2_instance_19_closures/2_instance_19_closures.php:3-3
     ; return  [] RANGE[0..0]
0000 CV0($x) = RECV 1
0001 BIND_STATIC CV1($y)
0002 T2 = DECLARE_LAMBDA_FUNCTION 0
0003 BIND_LEXICAL T2 CV0($x)
0004 RETURN T2
0005 RETURN null
LIVE RANGES:
     2: 0003 - 0004 (tmp/var)

{closure}:
     ; (lines=5, args=1, vars=2, tmps=1)
     ; (before optimizer)
     ; /.../PHP/19_closures/2_instance_19_closures/2_instance_19_closures.php:3-3
     ; return  [] RANGE[0..0]
0000 CV0($y) = RECV 1
0001 BIND_STATIC CV1($x)
0002 T2 = CONCAT CV1($x) CV0($y)
0003 RETURN T2
0004 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

In May 2023, this instance throws an error while trying to generate the CPG using Joern.

```scala
val x19 = (name, "19_closures_iall", cpg.call(".*DECLARE_LAMBDA_FUNCTION.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | Perfect             |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | no       | yes      | no        | no          | yes    | no    | yes            |
| 17 May 2023 | no       | yes      |           |             |        |       | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

When it is easier for a SAST tool, to capture named functions, can one just rewrite an unnamed function and name it?

</details>

</details>

</details>
