[//]: # (This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework.)

# Static Variables

Tags: sast, php, php_v7.4.9

Version: v1.0

## Description

This pattern targets `static` variables. When a function terminates, its local variables are destroyed. When we run that function again, new local variables will be allocated. If we want to keep one of those variables alive, we can use the `static` keyword. Static variables may be challenging for SAST tools: is a SAST tool considering a static variable used in a function as alive?

## Overview

| Instances                 | has discovery rule   | discovery method   | rule successfull   |
|---------------------------|----------------------|--------------------|--------------------|
| [1 Instance](#1-instance) | yes                  | joern              | yes                |

## 1 Instance

This instance, focuses on the static variables in functions not the static properties in objects nor static methods.

### Code

```PHP
<?php

function F($a) {
    static $b = 'abc'; // tarpit
    echo $b; // sink (moved out from standard skeleton)
    $b = $a;
}

$a = $_GET["p1"];  // source
F($a); // print "abc"
F('abc'); // print value of $_GET["p1"]
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=10, args=0, vars=1, tmps=5)
     ; (before optimizer)
     ; /.../PHP/1_static_variables/1_instance_1_static_variables/1_instance_1_static_variables.php:1-11
     ; return  [] RANGE[0..0]
0000 T1 = FETCH_R (global) string("_GET")
0001 T2 = FETCH_DIM_R T1 string("p1")
0002 ASSIGN CV0($a) T2
0003 INIT_FCALL 1 128 string("f")
0004 SEND_VAR CV0($a) 1
0005 DO_UCALL
0006 INIT_FCALL 1 128 string("f")
0007 SEND_VAL string("abc") 1
0008 DO_UCALL
0009 RETURN int(1)

F:
     ; (lines=5, args=1, vars=2, tmps=1)
     ; (before optimizer)
     ; /.../PHP/1_static_variables/1_instance_1_static_variables/1_instance_1_static_variables.php:3-7
     ; return  [] RANGE[0..0]
0000 CV0($a) = RECV 1
0001 BIND_STATIC (ref) CV1($b)
0002 ECHO CV1($b)
0003 ASSIGN CV1($b) CV0($a)
0004 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

To discover the static variables in opcode, I search for the opcode BIND_STATIC.
The `BIND_STATIC` opcode is only for static variables that are normally used inside code blocks. The SAST tools may not able to keep the proper values for these static variables. 
As such the discovery rule should be accurate as it is.

```scala
val x1 = (name, "1_static_variables_iall", cpg.call(".*BIND_STATIC.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | Perfect             |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | no       | no       | no        | no          | no     | no    | yes            |
| 17 May 2023 | no       | no       |           |             |        |       | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

Likely this tarpit should be solved at the SAST tool side. Transforming a static variable into a non-static one is unfeasible. It is unclear how to create a modeling rule for the static keyword.

</details>

</details>
