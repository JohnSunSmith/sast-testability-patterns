[//]: # (This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework.)

# Combined Operator

Tags: sast, php, php_v7.4.9

Version: v1.0

## Description

In PHP it is possible to combine multiple operators. For discovery, this pattern could profit from a discovery rule at source code level rather than a discovery rule at opcode level, as the combination of multiple operators in one line cannot be seen in opcode any more.

## Overview

| Instances                 | has discovery rule   | discovery method   | rule successfull   |
|---------------------------|----------------------|--------------------|--------------------|
| [1 Instance](#1-instance) | yes                  | joern              | yes                |
| [2 Instance](#2-instance) | yes                  | joern              | yes                |
| [3 Instance](#3-instance) | yes                  | joern              | yes                |

<details markdown="1"open>
<summary>

## 1 Instance
</summary>

This instance targets the usage of two assign statements in one line and shows, that the inner assign is a sink.

### Code

```PHP
<?php
$a = ($b = $_GET["p1"]) . " safe"; // source & tarpit
echo $b; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=7, args=0, vars=2, tmps=5)
     ; (before optimizer)
     ; /.../PHP/5_combined_operator/1_instance_5_combined_operator/1_instance_5_combined_operator.php:1-3
     ; return  [] RANGE[0..0]
0000 T2 = FETCH_R (global) string("_GET")
0001 T3 = FETCH_DIM_R T2 string("p1")
0002 T4 = ASSIGN CV1($b) T3
0003 T5 = CONCAT T4 string(" safe")
0004 ASSIGN CV0($a) T5
0005 ECHO CV1($b)
0006 RETURN int(1)
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The rule searches for the usage of `concat`, but that does not mean, that multiple operators have been combined here.

```scala
val x5 = (name, "5_combined_operator_i1", cpg.call(".*CONCAT.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | FP                  |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | yes      | yes      | no        | yes         | yes    | yes   | yes            |
| 17 May 2023 | yes      | yes      |           |             |        |       | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

One could split up the operations, by using one line for each operation. Would that be easier for a SAST tool?

</details>

</details>

</details>

<details markdown="1">
<summary>

## 2 Instance
</summary>

This instance targets the usage of two assign statements in one line and shows, that the outer assign is a sink.

### Code

```PHP
<?php
$a = ($b = $_GET["p1"]) . " safe"; // source & tarpit
echo $a; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=7, args=0, vars=2, tmps=5)
     ; (before optimizer)
     ; /.../PHP/5_combined_operator/2_instance_5_combined_operator/2_instance_5_combined_operator.php:1-3
     ; return  [] RANGE[0..0]
0000 T2 = FETCH_R (global) string("_GET")
0001 T3 = FETCH_DIM_R T2 string("p1")
0002 T4 = ASSIGN CV1($b) T3
0003 T5 = CONCAT T4 string(" safe")
0004 ASSIGN CV0($a) T5
0005 ECHO CV0($a)
0006 RETURN int(1)
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The discovery looks for an `ASSIGN` statement. The rule could be better, if we could check if the `ASSIGN` statement in the source code is in the same line as another `ASSIGN` statement.

```scala
val x5 = (name, "5_combined_operator_i2", cpg.call.code("(V|T).*=.*ASSIGN.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | FP                  |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | Ground Truth   |
|-------------|----------|----------|----------------|
| 17 May 2023 | yes      | yes      | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

One could split up the operations, by using one line for each operation. Would that be easier for a SAST tool?

</details>

</details>

</details>

<details markdown="1">
<summary>

## 3 Instance
</summary>

This instance shows the use of multiple assign statements in one line, but the source is only invoked by another indirection.

### Code

```PHP
<?php
$a = $_GET["p1"]; // source
$c = ($b = $a) . " safe"; // tarpit
echo $b; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=8, args=0, vars=3, tmps=6)
     ; (before optimizer)
     ; /.../PHP/5_combined_operator/3_instance_5_combined_operator/3_instance_5_combined_operator.php:1-4
     ; return  [] RANGE[0..0]
0000 T3 = FETCH_R (global) string("_GET")
0001 T4 = FETCH_DIM_R T3 string("p1")
0002 ASSIGN CV0($a) T4
0003 T6 = ASSIGN CV2($b) CV0($a)
0004 T7 = CONCAT T6 string(" safe")
0005 ASSIGN CV1($c) T7
0006 ECHO CV2($b)
0007 RETURN int(1)
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The discovery looks for an `ASSIGN` statement. The rule could be better, if we could check if the `ASSIGN` statement in the source code is in the same line as another `ASSIGN` statement.

```scala
val x5 = (name, "5_combined_operator_i3", cpg.call.code("(V|T).*=.*ASSIGN.*").location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | FP                  |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | Ground Truth   |
|-------------|----------|----------|----------------|
| 17 May 2023 | yes      | yes      | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

One could split up the operations, by using one line for each operation. Would that be easier for a SAST tool?

</details>

</details>

</details>
