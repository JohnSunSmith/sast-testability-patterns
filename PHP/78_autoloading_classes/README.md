[//]: # (This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework.)

# Autoloading Classes

Tags: sast, php, php_v7.4.9

Version: v1.0

## Description

PHP offers a feature for auto loading the classes instead of including them in each file [Autoloading classes](https://www.php.net/manual/en/language.oop5.autoload.php). It is a function will be called when the class is not exist, then this function will include the correct file for this class.

```php
<?php
spl_autoload_register(function ($class_name) {
include $class_name . '.php';
});
$obj  = new MyClass1();
$obj2 = new MyClass2();
```

In this article [How to use autoloading](https://www.smashingmagazine.com/2015/05/how-to-use-autoloading-and-a-plugin-container-in-wordpress-plugins/), they adopt [PEAR naming convention](https://pear.php.net/manual/en/standards.naming.php) for the class names.
> The gist is that class names are alphabetic characters in StudlyCaps. Each level of the hierarchy is separated with a single underscore. Class names will directly map to the directories in which they are stored.
>
> For example, A class named Simplarity_Plugin would be defined in the file src/Simplarity/Plugin.php.
>
> As you can see with this convention, the autoloader will just replace the underscores with directory separators to locate the class definition.
Finally, it is difficult for the static tool to find the class file.

## Overview

| Instances                 | has discovery rule   | discovery method   | rule successfull   |
|---------------------------|----------------------|--------------------|--------------------|
| [1 Instance](#1-instance) | yes                  | joern              | yes                |

## 1 Instance

The instance uses `spl_autoload_register` to load a class and than it creates an instance from that class.

### Code

```PHP
<?php
spl_autoload_register(function ($class_name) {
    include './'. $class_name . '.php';
});

$a = $_GET["p1"]; // source
$obj  = new MyClass1($a);

class MyClass1 {
    function __construct($b) {
        echo $b; // sink
    }
}
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| D2         | INTERNAL_API              | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=12, args=0, vars=2, tmps=8)
     ; (before optimizer)
     ; /.../PHP/78_autoloading_classes/1_instance_78_autoloading_classes/1_instance_78_autoloading_classes.php:1-14
     ; return  [] RANGE[0..0]
0000 INIT_FCALL 1 96 string("spl_autoload_register")
0001 T2 = DECLARE_LAMBDA_FUNCTION 0
0002 SEND_VAL T2 1
0003 DO_ICALL
0004 T4 = FETCH_R (global) string("_GET")
0005 T5 = FETCH_DIM_R T4 string("p1")
0006 ASSIGN CV0($a) T5
0007 V7 = NEW 1 string("MyClass1")
0008 SEND_VAR_EX CV0($a) 1
0009 DO_FCALL
0010 ASSIGN CV1($obj) V7
0011 RETURN int(1)
LIVE RANGES:
     7: 0008 - 0010 (new)

{closure}:
     ; (lines=5, args=1, vars=1, tmps=3)
     ; (before optimizer)
     ; /.../PHP/78_autoloading_classes/1_instance_78_autoloading_classes/1_instance_78_autoloading_classes.php:2-4
     ; return  [] RANGE[0..0]
0000 CV0($class_name) = RECV 1
0001 T1 = CONCAT string("./") CV0($class_name)
0002 T2 = CONCAT T1 string(".php")
0003 INCLUDE_OR_EVAL (include) T2
0004 RETURN null

MyClass1::__construct:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/78_autoloading_classes/1_instance_78_autoloading_classes/1_instance_78_autoloading_classes.php:10-12
     ; return  [] RANGE[0..0]
0000 CV0($b) = RECV 1
0001 ECHO CV0($b)
0002 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The rule searches for function calls to `spl_autoload_register` on opcode level.

```scala
val x78 = (name, "78_autoloading_classes_iall", cpg.call(".*INIT_FCALL.*").argument.order(2).code("spl_autoload_register").astParent.location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | Perfect             |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | yes      | yes      | no        | yes         | no     | no    | yes            |
| 22 May 2023 | yes      | yes      |           |             |        |       | yes            |

</details>

<details markdown="1">
<summary>

### Remediation
</summary>

The solution for this problem is to search for the name of the class in the whole project, then include the file. If there is more than one class with the same name, we have to do over-approximation by trying all the possible classes. In addition to that, we have to be careful to call the closure in spl_autoload_register every time we create an object because it could have a vulnerability.

</details>

</details>
